7.8	Flink状态编程
有状态的计算是流处理框架要实现的重要功能，因为稍复杂的流处理场景都需要记录状态，然后在新流入数据的基础上不断更新状态。
	SparkStreaming在状态管理这块做的不好, 很多时候需要借助于外部存储(例如Redis)来手动管理状态, 增加了编程的难度。
	Flink的状态管理是它的优势之一。
7.8.1	什么是状态
	在流式计算中有些操作一次处理一个独立的事件(比如解析一个事件), 有些操作却需要记住多个事件的信息(比如窗口操作)。
	那些需要记住多个事件信息的操作就是有状态的。
    流式计算分为无状态计算和有状态计算两种情况。
        	无状态的计算观察每个独立事件，并根据最后一个事件输出结果。例如，流处理应用程序从传感器接收水位数据，并在水位超过指定高度时发出警告。
        	有状态的计算则会基于多个事件输出结果。以下是一些例子。例如，计算过去一小时的平均水位，就是有状态的计算。所有用于复杂事件处理的状态机。
        例如，若在一分钟内收到两个相差20cm以上的水位差读数，则发出警告，这是有状态的计算。流与流之间的所有关联操作，以及流与静态表或动态表之间的关联操作，都是有状态的计算。
7.8.2	为什么需要管理状态
	下面的几个场景都需要使用流处理的状态功能:
	去重
	数据流中的数据有重复，我们想对重复数据去重，需要记录哪些数据已经流入过应用，当新数据流入时，根据已流入过的数据来判断去重。
	检测
	检查输入流是否符合某个特定的模式，需要将之前流入的元素以状态的形式缓存下来。比如，判断一个温度传感器数据流中的温度是否在持续上升。
	聚合
	对一个时间窗口内的数据进行聚合分析，分析一个小时内水位的情况。
	更新机器学习模型
	在线机器学习场景下，需要根据新流入数据不断更新机器学习的模型参数。
7.8.3	Flink中的状态分类
    Flink包括两种基本类型的状态Managed State和Raw State
                        Managed State	                                Raw State
    状态管理方式	Flink Runtime托管, 自动存储, 自动恢复, 自动伸缩	        用户自己管理
    状态数据结构	Flink提供多种常用数据结构, 例如:ListState, MapState等	    字节数组: byte[]
    使用场景	        绝大数Flink算子	                                    所有算子
    注意:
    1.	从具体使用场景来说，绝大多数的算子都可以通过继承Rich函数类或其他提供好的接口类，在里面使用Managed State。Raw State一般是在已有算子和Managed State不够用时，用户自定义算子时使用。
    2.	在我们平时的使用中Managed State已经足够我们使用, 下面重点学习Managed State
7.8.4	Managed State的分类
    对Managed State继续细分，它又有两种类型
    a)	Keyed State(键控状态)。
    b)	Operator State(算子状态)。

    	                    Operator State	                                        Keyed State
    适用用算子类型	可用于所有算子: 常用于source, 例如 FlinkKafkaConsumer	        只适用于KeyedStream上的算子
    状态分配	        一个算子的子任务对应一个状态	                                一个Key对应一个State: 一个算子会处理多个Key, 则访问相应的多个State
    创建和访问方式	实现CheckpointedFunction或ListCheckpointed(已经过时)接口	    重写RichFunction, 通过里面的RuntimeContext访问
    横向扩展	        并发改变时有多重重写分配方式可选: 均匀分配和合并后每个得到全量	并发改变, State随着Key在实例间迁移
    支持的数据结构	ListState和BroadCastState	                                ValueState, ListState,MapState ReduceState, AggregatingState
7.8.5	算子状态的使用
    Operator State可以用在所有算子上，每个算子子任务或者说每个算子实例共享一个状态，流入这个算子子任务的数据可以访问和更新这个状态。
    注意: 算子子任务之间的状态不能互相访问
    Operator State的实际应用场景不如Keyed State多，它经常被用在Source或Sink等算子上，用来保存流入数据的偏移量或对输出数据做缓存，以保证Flink应用的Exactly-Once语义。
Flink为算子状态提供三种基本数据结构：
    	列表状态（List state）
    将状态表示为一组数据的列表
    	联合列表状态（Union list state）
    也将状态表示为数据的列表。它与常规列表状态的区别在于，在发生故障时，或者从保存点（savepoint）启动应用程序时如何恢复。
    一种是均匀分配(List state)，另外一种是将所有 State 合并为全量 State 再分发给每个实例(Union list state)。
    	广播状态（Broadcast state）
    是一种特殊的算子状态. 如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态。
    广播状态
        从版本1.5.0开始，Apache Flink具有一种新的状态，称为广播状态。
        广播状态被引入以支持这样的用例:来自一个流的一些数据需要广播到所有下游任务，在那里它被本地存储，并用于处理另一个流上的所有传入元素。
        作为广播状态自然适合出现的一个例子，我们可以想象一个低吞吐量流，其中包含一组规则，我们希望根据来自另一个流的所有元素对这些规则进行评估。
        考虑到上述类型的用例，广播状态与其他操作符状态的区别在于:
        1. 它是一个map格式。
        2. 它只对输入有广播流和无广播流的特定操作符可用。
        3. 这样的操作符可以具有具有不同名称的多个广播状态。
7.8.6	键控状态的使用
    键控状态是根据输入数据流中定义的键（key）来维护和访问的。
    Flink为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个key对应的状态。
    当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的key。因此，具有相同key的所有数据都会访问相同的状态。
    Keyed State很类似于一个分布式的key-value map数据结构，只能用于KeyedStream（keyBy算子处理之后）。

    键控状态支持的数据类型
    	ValueState<T>
    保存单个值. 每个有key有一个状态值.  设置使用 update(T), 获取使用 T value()
    	ListState<T>:
    保存元素列表.
    添加元素: add(T)  addAll(List<T>)
    获取元素: Iterable<T> get()
    覆盖所有元素: update(List<T>)
    	ReducingState<T>:
    存储单个值, 表示把所有元素的聚合结果添加到状态中.  与ListState类似, 但是当使用add(T)的时候ReducingState会使用指定的ReduceFunction进行聚合.
    	AggregatingState<IN, OUT>:
    存储单个值. 与ReducingState类似, 都是进行聚合. 不同的是, AggregatingState的聚合的结果和元素类型可以不一样.
    	MapState<UK, UV>:
    存储键值对列表.
    添加键值对:  put(UK, UV) or putAll(Map<UK, UV>)
    根据key获取值: get(UK)
    获取所有: entries(), keys() and values()
    检测是否为空: isEmpty()
    注意:
    	所有的类型都有clear(), 清空当前key的状态
    	这些状态对象仅用于用户与状态进行交互.
    	状态不是必须存储到内存, 也可以存储在磁盘或者任意其他地方
    	从状态获取的值与输入元素的key相关




